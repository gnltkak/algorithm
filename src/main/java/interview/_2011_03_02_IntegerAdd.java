package interview;

//arithmetic operator(+,-,*,/,%) 를 사용하지 않고 integer 2개를 더하는 함수를 구현
public class _2011_03_02_IntegerAdd {
	public static int add(int a,int b) {
		if(b==0)
			return a;
		
		int n1 = a^b; //carry를 제외한 덧셈 결과
		int n2 = (a&b)<<1; //carry만 취한 덧셈 결과
		
		return add(n1,n2);
	}
}

/*
 * 1.
 * bit 연산자를 이용하여 덧셈을 한다.
 * carry, a, b 가 있을때
 * 이 중 1인 bit의 수가 짝수개이면 결과값의 bit는 0이 되고 홀수개이면 1이 된다.
 * 1인 bit의 수가 2개 이상이면 carry는 1이 되고 그렇지 않으면 0이 된다.
 * 2번 솔루션에 비해 코드가 길다.
 * 
 * 2.
 * carry를 제외한 덧셈 결과와 carry를 취한 덧셈결과를 더한다.
 * 10진수의 덧셈을 살펴보면 다음과 같다.
 *  456
 *  789
 *  ---
 *  135 (carry를 제외한 결과)
 * 1110 (carry만 고려한 결과)
 * 
 * 이를 2진법에 적용한다.
 * carry를 제외한 결과는 두 수를 xor 하면 되고
 * carry만 고려한 결과는 두 수를 and 하여 좌로 1 만큼 shift 하면 된다.
 * 두 수를 더하는 것은 recursive 하게 하면된다.
 * 
 * 그렇다면 종료조건은 어떻게 되는가?
 * carry가 0이면 종료조건이 성립한다.
 * 그렇다면 종료조건에 무조건 도달한다는 보장이 있는가?
 * (즉, 알고리즘이 무한루프에 빠지지 않는다는 보장이 있는가?)
 * 
 * 이를 수학적 귀납법으로 증명할 수 있다.
 * 우선 1bit 끼리의 연산을 할때 올바르게 동작함을 보인다.
 * 그리고 k bit 끼리의 연산이 올바르게 동작한다고 가정했을 때
 * (즉, carry의 하위 k bit가 언젠가 모두 0이 된다고 가정)
 * k+1 bit의 연산은 어떻게 되는지를 살펴본다.
 * 하위 k-bit 의 연산이 올바르게 동작하므로 하위 k-bit의 carry는 언젠가 0이 될 것이다.
 * ( k+1번째 bit와 하위 k개의 bit는 독립적으로 연산되므로 이런 관점이 옳다)
 * 이 때 carry의 k+1번째 bit는 1 아니면 0이다. 
 * carry를 제외한 결과도 마찬가지다. 즉 아래와 같은 상황이 된다.
 * 
 * yxxxx
 * 00000
 * 
 * 또는
 * 
 * yxxxx
 * 10000
 * 
 * (y는 0 또는 1)
 * 
 * 첫번째 경우는 아무 문제가 없고 두번째 경우를 살펴보자.
 * y가 0이든 1이든 다음번 carry는 모두 0이 된다.
 * ( 1 bit shift 됨을 상기하라)
 * 
 * 그러므로 위의 알고리즘은 무한루프에 빠지지 않는다.
 * 
 */
