package interview;

/*
 * n!의 trailing zero의 개수를 센다.
 */
public class _2011_03_03_factorialTrailingZeroCnt {
	public static int factTZeroCnt(int n) {
		int cnt = 0;
		for(int k=5;k<=n;k+=5)		
		{			
			for(int t=k;t%5==0;t/=5)
				cnt++;			
		}
		return cnt;
	}
	
	public static int factTZeroCntRef(int n) {
		int cnt = 0;
		for(int i=5;n/i>0;i*=5)
			cnt += n/i;
		return cnt;
	}
}

/*
 * 1.O(n)
 * n! 을 구한다음 10으로 나눠가며 개수를 센다.
 * string으로 바꿔서 해도 된다.
 * 심각한 문제는 n이 조금만 커져도 n!을 32 bit integer에 담을 수 없다는 것이다.
 * 
 * 2.O(k) (k는 답을 의미함)
 * 10은 2*5 로 만들어진다.
 * 따라서 n을 소인수 분해 했을 때 2의 개수와 5의 개수를 세서 둘중 작은 것을 취하면 된다.
 * but 5의 개수가 2의 개수보다 무조건 더 적다.
 * (2와 5가 나타나는 빈도를 생각해보라)
 * 따라서 5의 개수만 세면 된다.
 * 이것을 구현한 것이 factTZeroCnt() 이다.
 * 답이 k라면 안쪽 for 문이 도는 총 횟수가 k번 이므로 성능은 O(k)가 된다.
 * 5를 가지고 있는 수는 5의 배수 뿐이므로 5 10 15 20 ... 이런식으로 체크한다.
 * 
 * 3.O(logn) 
 * 5는 0을 만드는데에 1번 기여한다.
 * 25는 0을 만드는데에 2번 기여한다.
 * 125는 0을 만드는데에 3번 기여한다.
 * 
 * n=26 이라고 해보자.
 * 1~26 에서 5의 배수는 5,10,15,20,25 가 있다.
 * 이 수들이 0을 만드는데에 1번씩 기여한다.(25는 2번 기여하는데, 이것은 추후에 또 카운팅 될 것이다)
 * 다시말해 n/5 만큼 답에 + 해준다.
 * 
 * 1~26에서 25의 배수는 25가 있다.
 * n/25 를 답에 + 해준다.
 * (이로 인하여 25가 2번 카운팅되었다)
 * 
 * n/5 , n/5^2 , ... , n/5^p 이런식으로 카운트에 + 된다.
 * + 되는 값을 계산하는 것이 상수시간이므로 항의 개수가 성능이 된다.
 * 따라서 성능은 O(logn)이 된다.
 */
