package interview;

/*
 * facebook과 같은 매우 큰 소셜네트워크 서비스에 관한 문제이다.
 * A와 B가 몇촌간인지 ( 몇다리 건너야 알 수 있는지 ) 알아내는 문제이다.
 * A와 B 사이에 path가 여러개 있을수 있기 때문에 그 중 최단path를 찾아야 한다.
 * 
 */
public class _2011_01_27_SocialNetwork {

}

/*
 * 일단 자료구조는 당연히 그래프가 될 것이다.
 * A와 B가 몇촌간이고, 그 최단경로가 무엇인지 알아내려면 A* 알고리즘을 쓸 수 있다.
 * 그러나 이 경우 휴리스틱 함수 h(x) 의 값을 정할 수 없기 때문에 A*를 사용할 수 없다.
 * 그렇다고 다잌스트라 알고리즘을 사용하면 너무 낭비가 심해진다. 자 그러면 어떻게 할까.
 * 
 * A와 B 사이의 path 유무만 알려면 DFS를 해보면 되지만
 * 우리는 최단 경로를 알아내야 하기 때문에 BFS를 하는 것이 적절하다.
 * 맨 처음에는 1촌, 그다음에는 2촌, ... 이런식으로 BFS가 노드들을 방문할 것이다.
 * 문제는 노드의 수가 수억개정도 된다는 것인데, 여기서 약간의 상식을 적용해보자.
 * 사실 3다리 이상 건너가게 되면 실제로 알 확률이 매우 적다.
 * 그러므로 우리는 1촌,2촌 여부만 표시하고 그 이상은 3촌이상 으로 표시하기로 하자.
 * 그러면 BFS의 depth가 2까지만 갈 것이기 때문에 괜찮다고 볼 수 있다.
 * 성능상의 이유로 한 사람이 등록할 수 있는 최대 친구의 개수가 제한이 되어있는데, 이것을 k라고 하자.
 * (참고로 페이스북은 k값이 수천명 정도인것으로 알고 있다)
 * BFS가 depth 2 까지만 간다면 친구,친구의 친구를 모두 방문하므로 성능은 O(k^2)이 될 것이다.
 * 이것은 약간 비싸다는 감이 있다.
 * 우리가 알고 싶은 것은 두 사람 사이가 1촌인지 2촌인지 그 이상인지 이다.
 * 1촌인 경우는 인접 리스트를 그대로 살펴보면 되기 때문에 O(k)가 걸린다.
 * 2촌인지 판별하는 것은 사실 BFS를 할 필요가 없다.
 * A와 B 사이가 2촌이라면 반드시 공통된 1촌을 가질 것이기 때문에
 * A의 일촌과 B의 일촌간에 교집합이 있는지를 검사하면 된다. 즉 O(k) 가 된다.
 * 경로는 A-교집합인놈-B 가 될 것이다.
 * 그러므로 두 사람 사이가 1촌인지 2촌인지 3촌이상인지 살펴보는 데에는 O(k)의 시간이 걸린다.
 * 만약 1,2,3,4촌이상 으로 나눈다면 3촌인지를 살펴보는 데에서 2촌과 1촌의 교집합을 구해야하므로 O(k^2)이 될 것이다.
 * 
 * 여기서 끝이 아니다. 약간의 상식을 더 적용하자.
 * 사용자가 많기 때문에 인접 리스트들은 여러개의 머신에 저장되어 있을 것이다.
 * A와 B가 다른 머신에 있다면 머신 점프의 오버헤드가 추가로 발생할 것이다.
 * 이건 오버헤드를 줄이기 위해 사람들이 보통 같은 지역,국가끼리 친구관계를 맺는 경향이 있다는 사실을 이용하자.
 * 같은 지역끼리 같은 머신에 넣어두는 것이다.
 * 
 * 마지막으로, 캐싱에 대해 생각해보자.
 * 사실 캐싱을 하게 되면 서버에는 그만큼 부하가 더 생긴다. 캐시 일관성 유지 작업이 주된 원인일 것이다.
 * 하지만 사용자 입장에서는 반응성이 매우 좋아진다.
 * 자, 그러면 캐싱을 어떻게 할까.
 * 우리가 원하는 것은 A와 B 두사람간의 촌수 및 경로이므로
 * 인접 리스트에 추가정보를 넣어주면 된다.
 * A가 B의 사이트에 접속하면, 우선 A의 캐시에서 B와의 촌수 및 경로정보가 있는지 살펴본다.
 * 캐시에 있으면 그 정보를 출력하면 되고, 캐시에 없거나 캐시가 invalid 하면 O(k)의 작업으로 lookup 하여 캐시에 기록한다.
 * 
 * 그렇다면 캐시의 일관성이 언제 깨질까?
 * 당연히 그래프의 연결 정보가 변할 때이고, 새로운 친구관계가 설정되거나 기존 친구관계가 깨질 때이다.
 * C와 D가 친구가 되었다고 하자. (그림으로 그려보자)
 * 그러면 C와 D의 캐시뿐 아니라 C의 D의 1촌들의 캐시도 일관성이 깨진다. ( C,D의 2촌이상은 해당되지 않는다)
 * 따라서 이 경우 캐시를 최대 2k 번 무효화 해야 하므로 무효화 시키는데에 O(k) 의 오버헤드가 든다.
 * C와 D가 친구였다가 깨지면 어떻게 될까?
 * C와 D가 친구가 되었을 상황과 마찬가지로 O(k)의 오버헤드가 든다.
 * 그러므로 캐시 일관성을 유지하는 오버헤드는 O(k) 이다. 
 */
